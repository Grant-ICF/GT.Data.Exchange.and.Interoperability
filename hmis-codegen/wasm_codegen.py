"""
Generate Rust code from ontology for WASM compilation
Keeps Phase 1 minimal - just generates type inference logic
"""

from pathlib import Path
from typing import List
from .models import OntologyModel, OWLClass

class WASMCodeGenerator:
    """Generate Rust code for WASM module"""
    
    def generate_type_inference(self, ontology: OntologyModel) -> str:
        """Generate Rust type inference code from ontology classes"""
        
        code = [
            "// AUTO-GENERATED by hmis-codegen",
            "// DO NOT EDIT MANUALLY",
            "",
            "use serde_json::Value;",
            "",
            "pub fn infer_type(data: &serde_json::Map<String, Value>) -> Option<String> {",
        ]
        
        # Generate if-statements for each OWL class
        for cls in ontology.classes:
            # Get identifying properties for this class
            key_props = self._get_key_properties(cls)
            
            if key_props:
                conditions = " && ".join([
                    f'data.contains_key("{prop}")'
                    for prop in key_props[:2]  # Use first 2 properties
                ])
                
                code.append(f'    if {conditions} {{')
                code.append(f'        return Some("{cls.label}".to_string());')
                code.append('    }')
                code.append('')
        
        code.append('    None')
        code.append('}')
        
        return '\n'.join(code)
    
    def _get_key_properties(self, cls: OWLClass) -> List[str]:
        """Get identifying properties for a class"""
        # Simplified - in real implementation, use ontology metadata
        common_ids = ['ID', 'PersonalID', 'EnrollmentID', 'ProjectID']
        return [prop for prop in cls.properties if any(id in prop for id in common_ids)]